Architecture overview (current implementation + clarified target behavior)

- Purpose: Minimal web app to monitor targets, select a broker/server IP for a target, run backend-initiated actions, and manage remotely updatable target service deployments (per-device or per-group versions) while showing real-time status and logs.

- Frontend (Web UI, mobile-first):
  - Shows rectangular entries: green = online (recent updates), gray = offline (no update for ~10s).
  - Stable ordering:
    - New entries insert at the top of the online list.
    - While online, entries keep their position (updates do not reorder the list).
    - Offline entries are grouped and ordered by “went offline” time (newest offline first), derived from `offlineSince = lastUpdate + offlineTimeoutMs` so the ordering survives refresh.
    - When an offline entry becomes online again, it appends to the bottom of the online list.
  - Each entry shows: `Label — device IP · <age>` where `<age>` updates continuously (1 Hz) without re-rendering the full list.
    - Label defaults to UID when not provided.
    - For ages <60s show seconds; 60s+ show minutes.
  - Update UX: entry flashes light-green on update.
  - Selected IP is shown as a pressable rectangle/button:
    - Tap opens an IP list popup; selecting an IP shows a confirmation popup.
    - Tapping outside the popup cancels silently.
    - “Apply” button is not used.
    - Offline (gray) entries hide the selector and logs button.
  - Action feedback:
    - Progress `stage` is shown next to the selector as normal (non-red) text; it auto-clears after a short time on success.
    - Errors are shown in red next to the selector and persist until cleared by a later successful action.
    - The selected IP is kept visible even if an action fails (so the user can retry the same selection).
  - Logs:
    - Log view is a full-screen overlay (top of viewport) with Label/IP header, close button, tap-outside close, swipe-to-close.
    - Filter box highlights space-separated keywords in the stream.
  - Settings: Backend URL input is hidden behind a settings button/popup; changing it forces reconnect to the new backend.

- Backend (Node.js prototype):
  - HTTP:
    - `POST /api/ping` accepts `{uid, label, ip-address, state, data}` (uid required), refreshes device presence/state in memory and broadcasts a WebSocket delta.
    - `POST /api/action/select` records the selected IP and starts an action by opening a new connection from backend → device (action endpoint). Backend emits stage updates while it performs each real step and finally emits success or error to the UI. Action results are not embedded in `/api/ping`.
    - Updates (device pull):
      - `GET /api/device/manifest?uid=UID` returns a per-device manifest with `{version, artifact:{id,url,sha256}}`.
      - `GET /api/device/artifacts/<artifact-id>` serves the package bytes.
      - `GET /api/device/key?token=...` provisions an optional per-device transfer key (used by the updater for encrypted downloads).
    - Updates (artifact distribution):
      - Artifacts are stored by hash under `backend/data/artifacts/<sha256>` (artifact id = sha256).
      - Versions are tags in SQLite (`versions.version`) mapped to an artifact id (`versions.artifact_id`) imported via `node backend/tools/import_version.js`.
  - WebSocket:
    - Shared UI stream `/ws` sends `init` (full snapshot on connect) and `entry` deltas (per UID update).
    - Per-device log stream `/logs?uid=...` streams logs proxied from the device/service (in dev, the simulator acts as the device log source).
  - Device endpoint resolution (current dev implementation):
    - Host: the latest `ip-address` reported by the service.
    - Ports: `data.actionPort` / `data.logPort` reported by the service (fallback: backend config `deviceActionPort` / `deviceLogPort`).
  - Persistence:
    - SQLite via `sql.js` stores update artifacts + versions, per-device update targets, device transfer keys, and bootstrap tokens.
    - Live entry state (pings), action selections, and reported runtime versions stay in memory only.

- Target device / service (current direction):
  - Periodic status pings (POST), independent backend availability. (POST(s) are independent of actions)
  - Actions are initiated by backend by opening a new connection to the device; device does not need a persistent connection to the backend.
  - Device/service returns only final success or error for the action; backend stages come from backend execution steps and must not be time-invented (emit stages when each real step starts/finishes).
  - Service implementation (current stub):
    - `device-service/service.py` runs as a single-device process (intended for systemd).
    - Waits for an IPv4 on a configured interface (default `tun0`) and reports that address as `ip-address` in `POST /api/ping`.
    - Exposes TCP endpoints for backend→device connections:
      - action endpoint: `<bind-host>:<action-port>` returns `{ok:true|false, error?}`
      - log endpoint: `<bind-host>:<log-port>` streams newline-delimited logs
    - Reports `actionPort` / `logPort` in the `data` section of `POST /api/ping` (so ports can be per-device).
    - Reports version info in `data.version` (e.g. `serviceVersion`).
    - Note: on a single host, you can’t run two instances on the same `<bind-host>:<port>`; either bind to different IPs or use different ports.
  - Software updates (current prototype implementation):
    - Updater tool: `updater/updater.py` (intended to run as a systemd oneshot via timer).
    - Update loop:
      - Timer triggers updater → updater calls `GET /api/device/manifest?uid=...`
      - Updater downloads artifact from `artifact.url`, verifies SHA256, unpacks it into `/opt/vehicle-overseer/app/`,
        shifts the previous app to `/opt/vehicle-overseer/app.bak/`, then runs `update.sh install`.
    - Systemd templates:
      - Device service: `device-service/systemd/vehicle-overseer.service` (installed as `vehicle-overseer.service`)
      - Updater: `updater/systemd/updater.service` + `updater/systemd/updater.timer` (installed as `vehicle-overseer-updater.service|.timer`)
    - Device ID: manifest pull uses UID as the stable device identifier; backend resolves per-device/per-group targeting from DB.
    - Note: push-triggered updates via the existing backend→device action connection are not implemented yet (planned: “force update now” commands).

- Simulator (dev tool):
  - Implemented in python: posts multiple vehicles at different intervals for UI testing and can emulate device-side action failure/success responses.
  - Uses a Linux dummy interface (`vo-sim0`) with `10.0.0.0/24` addressing:
    - `net-setup` (sudo) creates/configures the interface and adds all IPs.
    - `net-cleanup` (sudo) removes the interface.
    - `run` binds to the already-configured IPs (no sudo).
