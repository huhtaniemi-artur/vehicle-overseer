# Updater (prototype)

This repo contains a pull-based updater design intended for Linux devices running systemd.

## Device-side pieces

- Service implementation: `device-service/service.py`
- Updater: `updater/updater.py`
- Systemd templates: `updater/systemd/`

The recommended on-device layout is:

- `/opt/vehicle-overseer/app/` (active app files, including `service.py` and `update.sh`)
- `/opt/vehicle-overseer/app.bak/` (previous app during update, removed after success)
- `/opt/vehicle-overseer/updater.py` (updater lives outside app)
- `/etc/vehicle-overseer/device.env` (device + backend settings)
- `/etc/vehicle-overseer/updater.env` (optional updater settings)

## Backend endpoints

- `GET /api/device/manifest?uid=DEVICE_UID`
- `GET /api/device/artifacts/<artifact-id>`
- `GET /api/device/key?token=...` (setup-time key provisioning; token required)
- `POST /api/bootstrap-token` (localhost-only; create a one-time or dev token)
- `GET /api/srvcsetup?label=...&token=...` (returns a bootstrap shell script)

## Artifact format

The updater expects a `.tar.gz` with files at the archive root, e.g.:

- `update.sh` (required, auto-generated by artifacts.js)
- `VERSION` (required, string matching manifest version)
- `updater/` (module directory)
  - `setup.sh` (installs/enables updater systemd units)
  - `systemd/updater.service`, `systemd/updater.timer`
  - `updater.py`
- `device-service/` (module directory)
  - `setup.sh` (installs/enables device service systemd unit)
  - `systemd/vehicle-overseer.service`
  - `service.py`

## How artifacts are created

Artifacts are created by `updater/artifacts.js` with a modular approach:

```bash
node updater/artifacts.js <version> --module <path> [--module <path>]... [--script <path>]
```

- `<version>`: Required version tag (e.g. `v0.1.0`)
- `--module`: Module directory to include (repeatable, order preserved)
- `--script`: Optional custom `update.sh` script

The tool:
1. Copies each module directory into the artifact under its basename
2. Validates that each module has `setup.sh` (warns if missing)
3. Generates `update.sh` that calls each module's `setup.sh` in order
4. Creates `VERSION` file from version argument
5. Builds inner `data` (tar.gz)
6. Computes SHA256 of the inner tarball, writes it to `hash`
7. Packages `hash` + `data` into an outer tar (uncompressed)
8. Outputs to `./data/artifacts/`

Example (run from `backend/` directory):
```bash
cd backend
node ../updater/artifacts.js v0.1.0 --module ../updater --module ../device-service
```

With custom update script:
```bash
node ../updater/artifacts.js v0.1.0 --module ../updater --module ../device-service --script ../custom-update.sh
```

## How backend discovers artifacts

Artifacts are stored to `<backend-cwd>/data/artifacts/`.

Backend syncs diskâ†”SQLite via the `refresh` command:

```bash
# From backend/ directory:
node src/artifacts_cli.js refresh

# Or via SEA binary:
./vehicle-overseer-backend artifacts refresh
```

The refresh command:
- Scans `<backend-cwd>/data/artifacts/` directory
- Reads `hash` file inside each tarball to get the artifact id
- Keeps the on-disk filename as-is and stores it in `artifacts.filename`
- Adds new artifacts to `artifacts` table
- Removes DB entries for missing files
- Reads `VERSION` from each tarball, populates `versions` table
- Updates `latest` to the most recently created version (newest `created_at`, then version desc)

## Notes

- Integrity: artifacts are double-wrapped. Outer tar holds `data` (inner tar.gz payload) and `hash`
  (SHA256 of `data`). Updater decrypts, reads `hash`, hashes `data`, compares, then extracts `data`.
  Backend does not recompute hashes.
- In-transfer encryption (always enabled):
  - Setup fetches a per-device base64 key from `GET /api/device/key?token=...`.
  - Response format is plain text: first line `deviceUid`, second line `keyB64`.
- Token creation: use `POST /api/bootstrap-token` (localhost only) to mint a token, then call `/api/srvcsetup?label=...&token=...`.
  - Example:
    - `curl -sS -X POST http://127.0.0.1:3100/api/bootstrap-token -H 'Content-Type: application/json' -d '{"kind":"dev"}'`
- The updater requires `VO_ARTIFACT_KEY_PATH` and requests encrypted downloads by adding `?uid=DEVICE_UID` to the artifact URL; backend responds with `X-VO-Enc: aes-256-ctr` + `X-VO-Iv: ...`.
- Device UID can be provided via `VO_DEVICE_UID` or a file at `/etc/vehicle-overseer/device.uid` (override with `VO_DEVICE_UID_PATH`).
- The updater swaps `app/` to `app.bak/`, installs the new app, runs `update.sh`, then removes `app.bak/` on success.
- Device can report per-device ports in `POST /api/ping` (`data.actionPort`, `data.logPort`); backend prefers these over global defaults when present.
- Service version info is reported in `POST /api/ping` as `data.version` (e.g. `serviceVersion`).
